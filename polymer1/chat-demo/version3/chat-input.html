<link rel="import" href="../../platform/custom-element/behaviors/common/o-crud-behavior.html">
<link rel="import" href="../personal_work_platform/base64-attachment-util-behavior.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../bower_components/iron-icons/editor-icons.html">
<link rel="import" href="./emoji-selector.html">
<link rel="import" href="../chat-history/chatting-room-history.html"/>

<dom-module id="chat-input">
  <template>

    <style>
      /* 滚动条相关 */
      :host ::-webkit-scrollbar {
        display: block;
        width: 6px;
        height: 6px;
      }
      :host ::-webkit-scrollbar-thumb {
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        height: 46px;
      }
      :host ::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
      }
      :host * {
        box-sizing: border-box;
      }
      :host .input-textarea {
        padding-right: 22px;
        padding-left: 25px;
        padding-top: 10px;
        height: 100%;
        width: calc(100% - 1px);
        overflow-y: scroll;
        color: #595757;
      }
      :host .input-textarea:focus {
        outline: none;
      }
      :host .input-container {
        position: relative;
        padding-bottom: 58.5px;
        height: 100%;
      }
      :host .send-button-container {
        position: absolute;
        bottom: 16.9px;
        right: 21px;
        width:68px;
        height:28px;
      }
      :host .send-button {
        width: 100%;
        height: 100%;
        color: white;
        background: rgba(0,150,235,1);
        border: none;
        cursor: pointer;
      }
      :host .send-button:active {
        background: rgb(0, 105, 235);
      }
      :host .display-flex{
        display: flex;
      }
    </style>
    <div class="input-container">
      <div class="display-flex">
        <emoji-selector></emoji-selector>
        <chatting-room-history chat-config="[[chatConfig]]"></chatting-room-history>
      </div>
      <div
        class="input-textarea"
        id="input-textarea"
        contenteditable="true"
        on-keydown="handleInputKeyDown"
        on-paste="pasteIntoTextArea"
        on-blur="handleTextAreaBlur"
        on-focus="handleTextAreaFocus"
      ></div>
      <div class="send-button-container">
        <button class="send-button" on-click="sendMessage">发送</button>
      </div>
    </div>


  </template>
  <script>
    Polymer({
      is: 'chat-input',
      behaviors: [OCrudBehavior, Base64AttachmentUtilBehavior, QqMsgPublishSubscribeBehavior],
      properties: {
        chatConfig: {
          type: Object
        },
        chatInputText: {
          type: String,
          value: '',
          notify: true
        },
        chatInputImgs: {
          type: Array,
          value: () => [],
          notify: true
        },
        currRange: {
          type: Object,
          value: null
        }
      },
      listeners: {
        'selected-emoji': 'textAreaChange'
      },
      ready() {
        let inputTextArea = Polymer.dom(this).node.querySelector('#input-textarea')
        inputTextArea.addEventListener('input', this.textAreaChange.bind(this))
      },
      getNewUuid () {
        return Math.random().toString(36).substr(2) + '-' + new Date().getTime()
      },
      saveAttachmentCallback (result) {
        // 上传回调，进行发送
        let params = this.formatSendingMessage(result.data.url, 2)
        if (!params) {
          return
        }
        params.attachmentIsUrl = true
        params.body.content = result.data.url
        params.uuid = result.data.uuid
        this.toSendMsg(params)
        this.fire('update-upload-image', { result })
      },
      formatSendingMessage (content, contentType) {
        let params = {}
        switch (this.chatConfig.chatType) {
          case 'QQgroup':
          case 'group':
            params = {
              fromUserId: this.chatConfig.fromUserId,
              groupIds: this.chatConfig.groupIds
            }
            break
          case 'private':
            params = {
              fromUserId: this.chatConfig.fromUserId,
              toUserIds: this.chatConfig.toUserIds
            }
            break
          default:
            return null
        }
        params.uuid = this.getNewUuid() // 生成该条信息的唯一标识符，用于判断 loading 状态
        params.body = {
          contentType,
          content
        }
        return params
      },
      sendMessage () {
        this.chatInputText = this._replaceEmojiToText()
        if (this.chatInputText.length > 600) {
          this.hTip.error('输入内容过长，请重新输入')
          return
        }
        let _send = (content, contentType) => {
          let params = this.formatSendingMessage(content, contentType)
          if (!params) {
            console.log('大家就当无事发生过')
            return
          }
          this.toSendMsg(params)
          this.fire('send-message', { params })
        }
        this.chatInputText.trim() &&
          _send(this.chatInputText, 1)
        this.chatInputImgs.forEach(item => {
          if (this.chatConfig.chatType === 'QQgroup') {
            // 如果是 QQ 群聊，需要手动进行图片上传后再发送
            let params = this.formatSendingMessage(item, 2)
            if (!params) {
              console.log('大家就当无事发生过')
              return
            }
            this.saveAttachment({ uuid: params.uuid, base64: params.body.content })
            this.fire('send-message', { params })
            return
          }
          _send(item, 2)
        })
        this.clearInputArea()
      },
      handleTextAreaBlur (e) {
        if (document.activeElement !== e.target) {
          Polymer.dom(this).node.querySelector('.input-container').style.outline = ''
        }
        this.saveRange(e.target)
      },
      saveRange (ele) {
        // 保存当前选区以插入图片
        const selection = window.getSelection()
        let range
        if (selection.getRangeAt && selection.rangeCount) {
          range = selection.getRangeAt(0)
        } else {
          range = window.createRange()
        }
        this.set('currRange', { ele, range })
      },
      handleTextAreaFocus (e) {
        if (document.activeElement === e.target) {
          Polymer.dom(this).node.querySelector('.input-container').style.outline = '-webkit-focus-ring-color auto 1px'
        }
      },
      handleInputKeyDown(e) {
        if (e.ctrlKey && e.key === 'Enter') {
          this.sendMessage()
        }
      },
      textAreaChange(e) {
        const textArea = Polymer.dom(this).node.querySelector('#input-textarea')
        let imgLists = textArea.querySelectorAll('img')
        this.set(
          'chatInputImgs',
          [...imgLists].map(item => item.src)
        )
        if (e && e.detail) {
          // 表情
          let img = document.createElement("img")
          const imgId = e.detail.replace(/[^\d]/g,'')
          const imgUrl = window.basePath + '/working_platform/chatting-room/assets/imgs/emoji/'+ imgId + '.png'
          this.insertImageToTextArea(imgUrl, false)
        }
        this.set('chatInputText', this.formatMessage(textArea.innerText))
      },
      // 插入图片至当前光标处
      insertImageToTextArea (src, isImage = true) {
        if (!this.currRange) {
          if (!src) return
          const image = new Image()
          image.src = src
          Polymer.dom(self.root).querySelector('#input-textarea').appendChild(image)
        }
        let range = this.currRange.range
        // 创建需追加到光标处节点的文档片段
        // isImage 用于区分该图片是否为表情包（表情包需要变成文字处理）
        let fragment = range.createContextualFragment(`<img ${!isImage && 'class="emoji-img"'} src="${src}">`)
        // 将创建的文档片段插入到光标处
        range.insertNode(fragment.lastChild)
      },
      pasteIntoTextArea(e) {
        e.stopPropagation()
        const self = this
        const { items, types } = e.clipboardData || e.originalEvent.clipboardData
        // 如果包含文件内容
        if (types.indexOf('Files') > -1) {
          e.preventDefault()
          for (let index = 0; index < items.length; index++) {
            const item = items[index]
            if (item.kind === 'file') {
              const file = item.getAsFile()
              if (file) {
                const reader = new FileReader()
                const image = new Image()
                reader.onloadend = function handleLoad () {
                  // image.src = this.result
                  self.saveRange()
                  self.insertImageToTextArea(this.result)
                  // Polymer.dom(self.root).querySelector('#input-textarea').appendChild(image)
                  /** 触发 textAreaChange **/
                  self.textAreaChange()
                }
                /** 触发 loadend **/
                reader.readAsDataURL(file)
              }
            }
          }
        }
        this.pasteText(e)
      },
      clearInputArea () {
        this.set('chatInputText', '')
        this.set('chatInputImgs', [])
        Polymer.dom(this).node.querySelector('#input-textarea').innerHTML = ''
      },
      formatMessage (message) {
        /** 格式化 Message **/
        let multiLines = message.split('\n')
        if (multiLines.length > 1) {
          /** 确保每行之间最多只有两个换行符 **/
          multiLines = multiLines.reduce((acc, curr) => {
            if (acc.length === 0) {
              if (curr === '') {
                return acc
              }
              acc.push(curr)
              return acc
            }
            if (acc[acc.length - 1] === '' && curr === '') {
              return acc
            }
            acc.push(curr)
            return acc
          }, [])
          return multiLines.join('\r\n')
        }
        return multiLines.join('\r\n')
      },
      pasteText (e) {
        // 处理复制纯文本
        e.preventDefault()
        let text
        let clp = (e.originalEvent || e).clipboardData
        if (clp === undefined || clp === null) {
          text = window.clipboardData.getData('text') || ''
          if (text !== '') {
            if (window.getSelection) {
              let newNode = document.createTextNode(text)
              window
                .getSelection()
                .getRangeAt(0)
                .insertNode(newNode)
            } else {
              document.selection.createRange().pasteHTML(text)
            }
          }
        } else {
          text = clp.getData('text/plain') || ''
          if (text !== '') {
            document.execCommand('insertText', false, text)
          }
        }
      },
      // 表情包转换成text格式
      _replaceEmojiToText: function () {
        const emojiList = document.querySelectorAll('.emoji-img')
        if (emojiList.length>0) {
          const innerContent = document.querySelector('#input-textarea').childNodes
          let formatContent = ''
          innerContent.forEach(ele => {
            if (ele.classList + '' === 'emoji-img') {
              const imgId = ele.src.match(/emoji\/(\S*)\.png/)[1]
              formatContent = formatContent + '###' + imgId + '###'
            } else {
              formatContent = formatContent + ele.nodeValue
            }
          })
          this.clearInputArea()
          return formatContent
        } else {
          return this.chatInputText
        }
      }
    })
  </script>
</dom-module>
